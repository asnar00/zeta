# ᕦ(ツ)ᕤ
# entity.py
# author: asnaroo
# zero to anything

from typing import List, Type, Tuple, Dict, Callable, TypeVar, Set
T = TypeVar('T')
from src.lexer import *

#--------------------------------------------------------------------------------------------------
# Entity is the base class for all AST Nodes

# Entity is the base class
class Entity:
    class_defs = {}                    # class name => text class definition (init method only)
    class_types = {}                   # class.attribute => type
    classes = {}                       # class name => class

    def __init__(self): self._error : Error = None
    def __str__(self):
        name = f"({self.get_name()})"
        return f"{self.__class__.__name__}{name}"
    def __repr__(self): return self.__str__()
    def get_name(self) -> str:
        if hasattr(self, "name"): return self.name
        for attr in vars(self):
            if attr == "_error": continue
            val = getattr(self, attr)
            if val is None: continue
            if isinstance(val, Entity): return val.get_name()
            elif isinstance(val, List) and len(val) > 0 and isinstance(val[0], Entity):
                for item in val:
                    if isinstance(item, Entity):
                        name = item.get_name()
                    if name: return name
        return ".."
    
    #----------------------------------------------------------------------------------------------
    # class building
    
    @staticmethod
    # given a class name, parent and list of typed attributes, build a class definition
    def build_class(name: str, parent: str, attributes: Dict[str, str]):
        if not parent: parent = "Entity"
        names = attributes.keys()
        types = attributes.values()
        init_param_list = ", ".join([f"{name}: '{type.replace("&", "")}' =None" for name, type in zip(names, types)])
        class_def = log_deindent(f"""
            class {name}({parent}):
                def __init__(self, {init_param_list}):
                    super().__init__()
            """)
        for attribute_name, attribute_type in attributes.items():
            ref = ""
            py_attribute_type = attribute_type
            if "&" in attribute_type:
                ref = "        # ref"
                py_attribute_type = attribute_type.replace("&", "")
            class_def += f"        self.{attribute_name}: {py_attribute_type} = {attribute_name}{ref}\n"
            Entity.class_types[f"{name}.{attribute_name}"] = attribute_type
        Entity.class_defs[name] = class_def

    @staticmethod
    # write all classe definitions to a text file
    def write_classes(path: str):
        preamble = log_deindent(f"""
            # ᕦ(ツ)ᕤ
            # {path.replace("src/", "")}
            # auto-generated by zeta.py
            # zero to anything

            from .entity import Entity
            from typing import List, Dict, Type
            """).lstrip()
        with open(path, "w") as f:
            f.write(preamble)
            for name, class_def in Entity.class_defs.items():
                f.write(class_def)
    
    @staticmethod
    # given class name and attribute name, return type
    def get_attribute_type(cls: Type, name: str) -> str:
        if name.endswith("]"): name = name[:name.rfind("[")] # strip trailing array []
        key = f"{cls.__name__}.{name}"
        if key not in Entity.class_types: return "None"
        return Entity.class_types[key]
    
    @staticmethod
    # given a class name, return the class
    def get_class(class_name: str) -> Type:
        class_name = class_name.replace("&", "")
        if class_name not in Entity.classes:
            raise Exception(f"can't find class {class_name}")
        return Entity.classes[class_name]
    
    @staticmethod
    # add method to class
    def method(cls: Type[T], method_name: str="") -> Callable:
        def decorator(func: Callable) -> Callable:
            class_name = cls.__name__
            # Convert standalone function to method
            @wraps(func)
            def method(self, *args, **kwargs):
                return func(self, *args, **kwargs)
            # Add the method to the class
            setattr(cls, func.__name__, method)
            # Important: return the original function or method
            return method
        return decorator
    
    @staticmethod
    # remove method from class
    def remove_method(cls: Type[T], method_name: str):
        if hasattr(cls, method_name): delattr(cls, method_name)
    
#----------------------------------------------------------------------------------------------
# debugging 

# detailed printout of every property of an entity
def dbg_entity(e: Entity|List[Entity], indent: int=0) ->str:
    out = ""
    start = "    " * indent
    if isinstance(e, Error): 
        return f"{start}{log_red(e)}\n"
    elif isinstance(e, Entity):
        out += f"{start}{e.__class__.__name__}\n"
        for attr in vars(e):
            if attr == "_error":
                if e._error != None:
                    out += f"{start}    {log_red(e._error)}\n"
                continue
            if attr.startswith("_"): continue
            type_name = Entity.get_attribute_type(e.__class__, attr)
            val = getattr(e, attr)
            if val == None or (isinstance(val, Lex) or isinstance(val, str)) or (isinstance(val, List) and len(val)==0):
                ref = ">" if (isinstance(val, Lex) or isinstance(val, str)) and type_name != "str" else ""
                out += f"{start}    {attr}: {type_name.replace("&", "")} ={ref} {val}\n"
            elif "&" in type_name:
                out += f"{start}    {attr} => {val}\n"
            else:
                if isinstance(val, list) and "List[" not in type_name:
                    type_name = f"List[{type_name}]"
                out += f"{start}    {attr}: {type_name.replace("&", "")}"
                if isinstance(val, list) and len(val) > 0:
                    out += "\n"
                    if isinstance(val[0], Entity):
                        for item in val:
                            out += dbg_entity(item, indent+2)
                    else:
                        type_in_brackets = type_name[5:-1]
                        ref = "=> " if type_in_brackets != "str" else ""
                        for item in val:
                            out += f"{start}        {ref}{item}\n"
                else: 
                    out += "\n"
                    out += dbg_entity(val, indent+2)
    return out

#-----------------------------------------------------------------------------------------------------------------------
# misc functions to help with entity stuff: these should probably go somewhere else, maybe in a new ast.py?

def get_first_lex(e: Entity|Lex) -> Lex:
    if isinstance(e, str): return Lex(source=None, pos=0, val=e, type=None)
    if isinstance(e, Lex): return e
    for attr in vars(e):
        if attr.startswith("_"): continue
        val = getattr(e, attr)
        if isinstance(val, Lex): return val
        attr_type = Entity.get_attribute_type(e.__class__, attr)
        if "&" in attr_type: continue
        vals = val if isinstance(val, list) else [val]
        if len(vals) > 0:
            for val in vals:
                lex = get_first_lex(val)
                if lex: return lex
    return None
    
def get_last_lex(e: Entity|Lex) -> Lex:
    if isinstance(e, str): return Lex(source=None, pos=0, val=e, type=None)
    if isinstance(e, Lex): return e
    if not hasattr(e, "__dict__"): return None
    for attr in reversed(vars(e)):
        if attr.startswith("_"): continue
        val = getattr(e, attr)
        if isinstance(val, Lex): return val
        attr_type = Entity.get_attribute_type(e.__class__, attr)
        if "&" in attr_type: continue
        vals = val if isinstance(val, list) else [val]
        if len(vals) > 0:
            for val in reversed(vals):
                lex = get_first_lex(val)
                if lex: return lex
    return None

#--------------------------------------------------------------------------------------------------
# Error represents something that went wrong during parsing

class Error:
    def __init__(self, lex: Lex, message: str, expected: str):
        self.lex = lex
        self.message = message
        self.expected = expected
    def __str__(self):
        loc = (str(self.lex.location())+" ") if self.lex else ""
        return f"{loc}{self.message}: expected {self.expected}"
    def __repr__(self): return self.__str__()

class Errors(Error):
    def __init__(self, errors: List[Error]):
        self.errors = errors
    def __str__(self):
        return "\n".join([str(error) for error in self.errors])
    def __repr__(self): return self.__str__()

#--------------------------------------------------------------------------------------------------
# visitor runs across the tree in specified order, calling method on each matching entity

class Visitor:
    trace : str = ""
    def __init__(self, has_method: str, is_ref: bool, children_first: bool):
        self.has_method = has_method                # method name to match, or None if all
        self.is_ref = is_ref                        # match only references, or None if don't care
        self.children_first = children_first        # visit children before calling fn, or not
        self.fn = None                              # function to call on each match
        self.vb = False

    def verbose(self, vb: bool): self.vb = vb

    def apply(self, e: Entity, fn: Callable):   # call this from outside
        self.fn = fn
        self.trace = ""
        self.visit_rec(e, None, set(), None, None, None, 0, "")

    # the main visitor recursive function... 
    def visit_rec(self, e: Entity, scope: Entity, visited: Set, parent: Entity, parent_attr: str, parent_index: int, indent:int, trace:str):        
        if not (isinstance(e, Entity) or isinstance(e, Lex)): return # allow addition of randomly-typed properties to ast entities

        if isinstance(e, Entity):        # don't visit the same one twice, unless we're a Lex
            if e in visited: return
            visited.add(e)

        trace = f"{trace}\n{' '*indent}{e}"
        Visitor.trace = trace
        
        entity_type_name, is_ref = self.get_type(parent, parent_attr) # find the attribute type
        
        match = self.is_match(e, is_ref) # check if this node matches the spec
        
        self.log(e, scope, match, indent, parent, parent_attr, parent_index, entity_type_name)
        
        # if we match, call the function (if children_first is False)
        if match and self.children_first == False:
            self.call_fn(e, scope, entity_type_name, parent, parent_attr, parent_index, indent)
        
        # visit children    
        if not isinstance(e, Lex) and not is_ref:
            self.visit_children(e, scope, visited, parent, indent, trace)
        
        # if we matched, call function (if children_first is True)
        if match and self.children_first == True:
            self.call_fn(e, scope, entity_type_name, parent, parent_attr, parent_index, indent)

    #----------------------------------------------------------------------------------------------
    # below the line 

    def get_type(self, parent: Entity, parent_attr: str):
        attr_type_name = Entity.get_attribute_type(parent.__class__, parent_attr) if parent else ""
        is_ref = "&" in attr_type_name
        entity_type_name = attr_type_name.replace("List[", "").replace("]", "").replace("&", "")
        return entity_type_name, is_ref
    
    def is_match(self, e: Entity|Lex, is_ref: bool):
        if self.has_method and not hasattr(e, self.has_method): return False
        if isinstance(e, Entity):
            if is_ref: return False # never traverse references!
            if self.has_method and not hasattr(e, self.has_method):
                return False
        elif isinstance(e, Lex): # safe to traverse references, but only if requested
            if self.is_ref != None:
                if self.is_ref != is_ref:
                    return False
        return True

    def call_fn(self, e: Entity, scope: Entity, entity_type_name: str, parent: Entity, parent_attr: str, parent_index: int, indent: int):
        start = " " * indent
        new_node = self.fn(e, scope, entity_type_name)
        if new_node: 
            if self.vb: log(log_green(f"{start}set {parent}.{parent_attr} ==> {new_node}"))
            self.set_node(new_node, parent, parent_attr, parent_index, indent)
           
    def visit_children(self, e: Entity, scope: Entity, visited: Set, parent: Entity, indent:int, trace:str):
        start = " " * indent

        if hasattr(e, "get_scope"):
            scope = e.get_scope() or scope
            if not isinstance(scope, Entity):
                log(log_red(f"{e}.get_scope returned {scope} ({type(scope).__name__})"))
                return
            
        for attr in vars(e):
            val = getattr(e, attr)
            if val is None: continue
            type_name, is_ref = self.get_type(e, attr)
            is_list = isinstance(val, List)
            if is_list:
                if len(val) == 0: continue
                for i, val in enumerate(val):
                    if not (is_ref and isinstance(val, Entity)): # don't traverse references
                        self.visit_rec(val, scope, visited, e, attr, i, indent+1, trace)
            else:
                if not (is_ref and isinstance(val, Entity)): # don't traverse references
                    self.visit_rec(val, scope, visited, e, attr, None, indent+1, trace)


    def visit_attrs(self, attrs: List[Tuple[str, Entity]], e: Entity, scope: Entity, visited: Set, parent: Entity, indent:int):
        for attr, attr_val in attrs:
            if attr == "_error": continue
            is_list = isinstance(attr_val, List)
            if is_list:
                for i, val in enumerate(attr_val):
                    self.visit_rec(val, scope, visited, e, attr, i, indent+1)
            else:
                self.visit_rec(attr_val, scope, visited, e, attr, None, indent+1)

    def set_node(self, new_node: Entity, parent: Entity, attr: str, index: int, indent:int):
        start = " " * indent
        ind = f"[{index}]" if index else ""
        if not parent: return
        if index == None: setattr(parent, attr, new_node)
        else: getattr(parent, attr)[index] = new_node

    def log(self, e: Entity, scope: Entity,match: bool, indent: int, parent: Entity, parent_attr: str, parent_index: int, entity_type_name: str):
        if not self.vb: return
        start = " " * indent
        se = f"{e}" if isinstance(e, Entity) else f'"{e}"'
        log(f"{start}{se} in {scope}")

    def vblog(self, *args):
        if not self.vb: return
        log(*args)

#--------------------------------------------------------------------------------------------------
# test-test

def test_symbol_table(st):
    d = st.dbg()
    

